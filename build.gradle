buildscript {
	repositories {
		mavenCentral()
//		maven {
//			url "http://127.0.0.1:8081/artifactory/libs-release"
//			allowInsecureProtocol true
//		}
	}
	dependencies {
		classpath("io.spring.javaformat:spring-javaformat-gradle-plugin:0.0.39")
	}
}

plugins {
	id 'java'
	id 'jacoco'
	id 'org.springframework.boot' version '3.2.1'
	id 'io.spring.dependency-management' version '1.1.4'
	id 'org.hibernate.orm' version '6.3.1.Final'
	id 'org.sonarqube' version '4.0.0.2929'
}

apply plugin: 'io.spring.javaformat'

group = 'code.shubham'
version = '0.0.1'

java {
	sourceCompatibility = '21'
}

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
	all {
		exclude group: 'org.springframework.boot', module: 'spring-boot-starter-logging'
		exclude group: 'ch.qos.logback', module: 'logback-classic'
	}
}

repositories {
	mavenCentral()
//	maven {
//		url "http://127.0.0.1:8081/artifactory/libs-release"
//		allowInsecureProtocol true
//	}
}

ext {
	set('springCloudVersion', "2023.0.0")
}

dependencies {
	annotationProcessor (
			'org.projectlombok:lombok',
	)
	compileOnly (
			'org.projectlombok:lombok',
	)
	developmentOnly (
			'org.springframework.boot:spring-boot-devtools',
	)
	implementation(
			'org.springframework.boot:spring-boot-starter-artemis',
			'org.apache.activemq:artemis-jms-server:2.30.0',
			'com.fasterxml.jackson.core:jackson-databind',

			'org.springframework.boot:spring-boot-starter-actuator',

			'org.springframework.boot:spring-boot-starter-log4j2',
			'com.lmax:disruptor:3.3.6',
	)
	runtimeOnly (
			'io.micrometer:micrometer-registry-prometheus',
	)
	testImplementation (
			'org.springframework.boot:spring-boot-starter-test',
			'org.awaitility:awaitility:4.2.0',
	)
}

hibernate {
	enhancement {
		enableAssociationManagement = true
	}
}


tasks.withType(io.spring.javaformat.gradle.tasks.CheckFormat) {
}

tasks.named('test') {
	useJUnitPlatform()
	finalizedBy(jacocoTestReport)
//	afterSuite { desc, result ->
//		if (!desc.parent)
//			println("${result.resultType} " +
//					"(${result.testCount} tests, " +
//					"${result.successfulTestCount} successes, " +
//					"${result.failedTestCount} failures, " +
//					"${result.skippedTestCount} skipped)")
}

tasks.named('test') {
	useJUnitPlatform()
	finalizedBy(jacocoTestReport)
	afterSuite { desc, result ->
		if (!desc.parent)
			println("${result.resultType} " +
					"(${result.testCount} tests, " +
					"${result.successfulTestCount} successes, " +
					"${result.failedTestCount} failures, " +
					"${result.skippedTestCount} skipped)")
	}
}

jacocoTestReport {
	dependsOn(test)
	afterEvaluate {
		classDirectories = files(classDirectories.files.collect {
			fileTree(dir: it,
					exclude: [
							'**/entities',
							'**/*models',
							'code/shubham/*/*/*/entities/**',
							'code/shubham/*/*/*/*/entities/**',
							'code/shubham/*/*/entities/**',
							'code/shubham/*/*models/**',
							'code/shubham/*/*/*models',
							'code/shubham/*/exceptions',
							'code/shubham/*/filters'
					]
			)
		})
	}
}

jacocoTestCoverageVerification {
	dependsOn(jacocoTestReport)
	violationRules {
		rule {
			enabled = true
			limit {
				minimum = 0.0
			}
		}
	}
}

sonar {
	properties {
		property('sonar.host.url', 'http://localhost:9017')
		property('sonar.java.coveragePlugin', 'jacoco')
		property('sonar.jacoco.reportPath', 'build/jacoco/test.exec')
		property('sonar.binaries', 'build/classes')
		property('sonar.language', 'java')
	}
}

tasks['sonar'].dependsOn jacocoTestReport